---
title: Deploying a Stellar Asset Contract (SAC) from within a contract.
---

<head>
  <title>
    {`Deploying a Stellar Asset Contract (SAC) from within a contract`}
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Deploying a Stellar Asset Contract (SAC) from within a contract"
  />
  <meta
    property="og:description"
    content="This is a step-by-step guide to help you deploy an SAC from within a smart contract on Stellar."
  />
</head>

## Overview

In this guide, you'll learn how to deploy a Stellar Asset Contract (SAC) from within another smart contract using the Soroban SDK. 
The Soroban SDK provides tools and utilities for working with Stellar smart contracts, allowing you to deploy and interact with SACs directly from your contract logic.

### Prerequisites:

Before you begin, make sure you have the following:

- Basic understanding of [Rust programming language](https://www.rust-lang.org/). To brush up on Rust, check out [Rustlings](https://github.com/rust-lang/rustlings) or [The Rust book](https://doc.rust-lang.org/book/).
- Soroban SDK: Installed and configured in your development environment.
- Basic understanding of Soroban SDK: Familiarity with Soroban's core concepts and Rust programming.

### Steps to Deploy a Stellar Asset Contract (SAC)

1. Define the SacDeployer Contract
The SacDeployer contract will be responsible for deploying the Stellar Asset Contract. Below is the code for the SacDeployer contract.

```rust title="lib.rs"

use soroban_sdk::{contract, contractimpl, Env, Address, Bytes};

#[contract]
pub struct SacDeployer;

#[contractimpl]
impl SacDeployer {
    pub fn deploy_sac(env: Env, serialized_asset: Bytes) -> Address {
        // Create the Deployer with Asset
        let deployer = env.deployer().with_stellar_asset(serialized_asset);
        let _ = deployer.deployed_address();
        // Deploy the Stellar Asset Contract
        let sac_address = deployer.deploy();

        sac_address
    }
}

```

### 2. Explanation

- `SacDeployer` Contract: This contract defines the deploy_sac function to handle the deployment of the SAC.
- `deploy_sac` Function:
  - `env.deployer().with_stellar_asset(serialized_asset)`: Creates a deployer configured to deploy a Stellar Asset Contract using the provided serialized asset.
  - `deployer.deploy()`: Deploys the SAC and returns the address of the deployed contract.


### 3. Testing the Deployment
You need to test the deployment to ensure everything works as expected. The following code demonstrates how to test the SacDeployer contract using the Soroban SDK's test utilities.

```rust
#[cfg(feature = "testutils")]
fn main() {
    let env = TestEnv::default();
    let serialized_asset = Bytes::from("actual serialized asset"); // Replace with actual serialized asset info
    let sac_deployer = SacDeployer::default();
        
    let sac_address = sac_deployer.deploy_sac(env.clone(), serialized_asset);
    println!("SAC Address: {}", sac_address.to_string());

    assert!(sac_address.to_string().len() > 0, "SAC address should be non-empty");
}

```

### 4. Explanation

- `TestEnv::default()`: Creates a default testing environment for the deployment.

- `SacDeployer::default()`: Initializes the SacDeployer contract.

- `deploy_sac(env.clone()`, serialized_asset): Calls the deploy_sac function to deploy the SAC and retrieves the address.

- `println!("SAC Address: {}", sac_address.to_string())`: Prints the address of the deployed SAC.

- `assert!(sac_address.to_string().len() > 0, "SAC address should be non-empty")`: Asserts that the SAC address is non-empty, ensuring a successful deployment.


## Conclusion

By following this guide, youâ€™ve successfully deployed a Stellar Asset Contract from within another contract using the Soroban SDK. 
This approach enables smart contracts to handle SAC deployments dynamically, providing flexibility for various use cases in the Stellar ecosystem.


For further details, refer to the Soroban SDK documentation and explore more advanced features and configurations.